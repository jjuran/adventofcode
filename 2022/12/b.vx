#!/usr/bin/env minivx

let bindir = dirname realpath argv[ 0 ]
let libdir = bindir "/../../lib/"

let import = { let path = libdir _ ".vsl"; eval( load path, path ) }

let display = (import "status") { OUT <== _ }

let input_path = if argc > 1 then {argv[ 1 ]} else {bindir "/input.txt"}

var data = load input_path

let len = data.length
let lines = data.lines()
let height = lines.length
let width = lines[ 0 ].length
let stride = width + 1

let start = (begin data).find('S').past.length
let goal  = (begin data).find('E').past.length

data[ start ] = 'a'
data[ goal  ] = 'z'

def neighbors (index)
{
	return
	[
		index - 1, index - stride,
		index + 1, index + stride,
	]
}

def dijkstra_shortest (start, goal)
{
	var seen = x"00" * (height * stride)
	
	var distance = 0
	
	var frontier = [ start ]
	
	while frontier do
	{
		var new_frontier = []
		
		for i in frontier do
		{
			if i == goal then
			{
				return distance
			}
			
			if not seen[ i ] then
			{
				let c = data[ i ]
				
				seen[ i ] = c
				
				let next = 'a' .. byte (u8 c + 1)
				
				for j in neighbors i do
				{
					if j in 0 -> len and data[ j ] in next then
					{
						new_frontier <-- j
					}
				}
			}
		}
		
		++distance
		
		frontier <- new_frontier
	}
	
	return ()
}

def find_starts
{
	var result = []
	
	var p = begin data
	
	while p = p.find 'a' do
	{
		let i = p.past.length
		
		result <-- i
		
		++p
	}
	
	return result
}

let starts = find_starts()

let n = starts.length
var i = 0

var best = ()

for s in starts do
{
	display ++i " of " n (" (best: %s)" % rep best)
	
	let distance = dijkstra_shortest (s, goal)
	
	best = Math.min (best, distance)
}

display ""

print best
